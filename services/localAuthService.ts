import * as Crypto from 'expo-crypto';
import { localDatabaseService, LocalUserCredentials } from './localDatabaseService';

export interface LocalUserCredentialsLegacy {
  email: string;
  password: string; // Ser√° criptografada
  lastLogin: string;
  isValidated: boolean;
  sessionId?: string;
}

class LocalAuthService {
  private readonly ENCRYPTION_KEY = 'mtfa_auth_key_2024';

  // Criptografar senha
  private async encryptPassword(password: string): Promise<string> {
    try {
      const hash = await Crypto.digestStringAsync(
        Crypto.CryptoDigestAlgorithm.SHA256,
        password + this.ENCRYPTION_KEY,
        { encoding: Crypto.CryptoEncoding.BASE64 }
      );
      return hash;
    } catch (error) {
      console.error('Erro ao criptografar senha:', error);
      return password; // Fallback sem criptografia
    }
  }

  // Verificar senha comparando com hash
  private async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    try {
      const hash = await Crypto.digestStringAsync(
        Crypto.CryptoDigestAlgorithm.SHA256,
        password + this.ENCRYPTION_KEY,
        { encoding: Crypto.CryptoEncoding.BASE64 }
      );
      return hash === hashedPassword;
    } catch (error) {
      console.error('Erro ao verificar senha:', error);
      return false;
    }
  }

  // Salvar credenciais ap√≥s login online bem-sucedido
  async saveCredentials(email: string, password: string, sessionId?: string): Promise<boolean> {
    try {
      const hashedPassword = await this.encryptPassword(password);
      
      const success = await localDatabaseService.saveUserCredentials(email, hashedPassword, sessionId);
      
      if (success) {
      } else {
      }
      
      return success;
    } catch (error) {
      console.error('‚ùå Erro ao salvar credenciais:', error);
      return false;
    }
  }

  // Verificar se h√° credenciais salvas
  async hasStoredCredentials(): Promise<boolean> {
    try {
      const hasCredentials = await localDatabaseService.hasUserCredentials();
      return hasCredentials;
    } catch (error) {
      console.error('‚ùå Erro ao verificar credenciais armazenadas:', error);
      return false;
    }
  }

  // Obter credenciais salvas por email espec√≠fico
  async getStoredCredentialsByEmail(email: string): Promise<LocalUserCredentialsLegacy | null> {
    try {
('üìã Obtendo credenciais salvas do SQLite para:', email);
      
      const credentials = await localDatabaseService.getUserCredentials(email);
      
      if (!credentials) {
('üìã Nenhuma credencial encontrada para:', email);
        return null;
      }

      // Converter para o formato legado esperado pelo c√≥digo existente
      const legacyCredentials: LocalUserCredentialsLegacy = {
        email: credentials.email,
        password: credentials.password_hash,
        lastLogin: credentials.last_login,
        isValidated: credentials.is_validated === 1,
        sessionId: credentials.session_id
      };

('üìã Credenciais obtidas para:', legacyCredentials.email);
      return legacyCredentials;
    } catch (error) {
      console.error('‚ùå Erro ao obter credenciais armazenadas:', error);
      return null;
    }
  }

  // Obter credenciais salvas (retorna a primeira credencial encontrada)
  async getStoredCredentials(): Promise<LocalUserCredentialsLegacy | null> {
    try {
('üìã Obtendo credenciais salvas do SQLite...');
      
      // Buscar a primeira credencial dispon√≠vel
      const credentials = await localDatabaseService.getFirstUserCredentials();
      
      if (!credentials) {
('üìã Nenhuma credencial encontrada');
        return null;
      }

      // Converter para o formato legado esperado pelo c√≥digo existente
      const legacyCredentials: LocalUserCredentialsLegacy = {
        email: credentials.email,
        password: credentials.password_hash,
        lastLogin: credentials.last_login,
        isValidated: credentials.is_validated === 1,
        sessionId: credentials.session_id
      };

('üìã Credenciais obtidas para:', legacyCredentials.email);
      return legacyCredentials;
    } catch (error) {
      console.error('‚ùå Erro ao obter credenciais armazenadas:', error);
      return null;
    }
  }

  // Validar login offline
  async validateOfflineLogin(email: string, password: string): Promise<{
    success: boolean;
    message: string;
    credentials?: LocalUserCredentialsLegacy;
  }> {
    try {
('üîç Tentando login offline para:', email);
      
      const storedCredentials = await this.getStoredCredentialsByEmail(email);
      
      if (!storedCredentials) {
('‚ùå Nenhuma credencial salva encontrada para:', email);
        return {
          success: false,
          message: 'Nenhuma credencial salva encontrada. Fa√ßa login online primeiro.'
        };
      }

('üìã Credenciais encontradas para:', storedCredentials.email);

      // Verificar se as credenciais ainda s√£o v√°lidas (√∫ltimo login h√° menos de 30 dias)
      const lastLogin = new Date(storedCredentials.lastLogin);
      const now = new Date();
      const daysDiff = (now.getTime() - lastLogin.getTime()) / (1000 * 60 * 60 * 24);

('üìÖ Dias desde √∫ltimo login:', daysDiff);

      if (daysDiff > 30) {
('‚ùå Credenciais expiradas');
        return {
          success: false,
          message: 'Credenciais expiradas. Fa√ßa login online novamente.'
        };
      }

      // Verificar senha
      const isPasswordValid = await this.verifyPassword(password, storedCredentials.password);
      
      if (!isPasswordValid) {
('‚ùå Senha incorreta');
        return {
          success: false,
          message: 'Senha incorreta.'
        };
      }

('‚úÖ Login offline bem-sucedido');
      return {
        success: true,
        message: 'Login offline realizado com sucesso.',
        credentials: storedCredentials
      };
    } catch (error) {
      console.error('‚ùå Erro na valida√ß√£o offline:', error);
      return {
        success: false,
        message: 'Falha na valida√ß√£o offline. Tente novamente.'
      };
    }
  }

  // Atualizar senha quando login online detecta mudan√ßa
  async updatePassword(email: string, newPassword: string, sessionId?: string): Promise<boolean> {
    try {
('üîÑ Atualizando senha para:', email);
      const hashedNewPassword = await this.encryptPassword(newPassword);
      
      const success = await localDatabaseService.saveUserCredentials(email, hashedNewPassword, sessionId);
      
      if (success) {
('‚úÖ Senha atualizada para:', email);
      } else {
('‚ùå Falha ao atualizar senha para:', email);
      }
      
      return success;
    } catch (error) {
      console.error('‚ùå Erro ao atualizar senha:', error);
      return false;
    }
  }

  // Limpar credenciais (logout)
  async clearCredentials(): Promise<boolean> {
    try {
('üßπ Limpando credenciais do SQLite...');
      const success = await localDatabaseService.clearUserCredentials();
      
      if (success) {
('‚úÖ Credenciais removidas do SQLite');
      } else {
('‚ùå Falha ao remover credenciais do SQLite');
      }
      
      return success;
    } catch (error) {
      console.error('‚ùå Erro ao limpar credenciais:', error);
      return false;
    }
  }

  // Verificar se pode fazer login offline
  async canLoginOffline(): Promise<boolean> {
    try {
('üîç Verificando se pode fazer login offline...');
      const hasCredentials = await this.hasStoredCredentials();
      
      if (!hasCredentials) {
('‚ùå N√£o h√° credenciais salvas para login offline');
        return false;
      }

      // Verificar se h√° pelo menos uma credencial v√°lida
      const credentials = await this.getStoredCredentials();
      if (!credentials) {
('‚ùå N√£o foi poss√≠vel obter credenciais para verifica√ß√£o');
        return false;
      }

      const lastLogin = new Date(credentials.lastLogin);
      const now = new Date();
      const daysDiff = (now.getTime() - lastLogin.getTime()) / (1000 * 60 * 60 * 24);

      const canLogin = daysDiff <= 30 && credentials.isValidated;
('üîç Pode fazer login offline?', canLogin, '(dias:', daysDiff, ')');
      
      return canLogin;
    } catch (error) {
      console.error('‚ùå Erro ao verificar login offline:', error);
      return false;
    }
  }
}

export const localAuthService = new LocalAuthService();
